#!/bin/bash
# Copyright 2019 Ciena Corporation
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
TOTAL_START_TIME=$(date +%s)

FANCY=${FANCY:-1}
if [ "$TERM X" == " X" ]; then
    FANCY=0
fi

# trap ctrl-c and call ctrl_c()
trap ctrl_c INT

function ctrl_c() {
    echo -en $CNORM
    echo ""
    echo "ctrl-c trapped"
    echo "Thank you for trying 'voltha up'"
    exit
}

VOLTCTL_VERSION=${VOLTCTL_VERSION:-latest}
KIND_VERSION=${KIND_VERSION:-v0.5.1}
VK_RELEASE=${VK_RELEASE:-master}

BLACK=
RED=
GREEN=
YELLOW=
BLUE=
MAGENTA=
CYAN=
WHITE=
BOLD=
NORMAL=
ERROR=
CEOL=
CNORM=
CIVIS=
if [ $FANCY -eq 1 ]; then
    BLACK=$(tput setaf 0)
    RED=$(tput setaf 1)
    GREEN=$(tput setaf 2)
    YELLOW=$(tput setaf 3)
    BLUE=$(tput setaf 4)
    MAGENTA=$(tput setaf 5)
    CYAN=$(tput setaf 6)
    WHITE=$(tput setaf 7)
    BOLD=$(tput bold)
    NORMAL=$(tput sgr0)
    ERROR="\xe2\x9c\x97\x20"
    CEOL=$(tput el)
    CNORM=$(tput cnorm)
    CIVIS=$(tput civis)
fi

TYPE=${TYPE:-minimal}
NAME=${NAME:-$TYPE}

ENABLE_ONOS_EXTRANEOUS_RULES=${ENABLE_ONOS_EXTRANEOUS_RULES:-no}
WITH_TIMINGS=${WITH_TIMINGS:-no}
WITH_BBSIM=${WITH_BBSIM:-no}
WITH_RADIUS=${WITH_RADIUS:-no}
WITH_EAPOL=${WITH_EAPOL:-yes}
WITH_DHCP=${WITH_DHCP:-yes}
WITH_IGMP=${WITH_IGMP:-no}
WITH_ONOS=${WITH_ONOS:-yes}
WITH_SECOND_ONOS=${WITH_SECOND_ONOS:-no}
WITH_CHAOS=${WITH_CHAOS:-no}
WITH_ADAPTERS=${WITH_ADAPTERS:-yes}
WITH_SIM_ADAPTERS=${WITH_SIM_ADAPTERS:-no}
WITH_OPEN_ADAPTERS=${WITH_OPEN_ADAPTERS:-yes}
WITH_PORT_FORWARDS=${WITH_PORT_FORWARDS:-yes}
ONLY_ONE=${ONLY_ONE:-yes}
CONFIG_SADIS=${CONFIG_SADIS:-no} # yes | no | file | bbsim | URL
SADIS_SUBSCRIBERS=${SADIS_SUBSCRIBERS:-http://bbsim.voltha.svc:50074/v2/subscribers/%s}
SADIS_BANDWIDTH_PROFILES=${SADIS_BANDWIDTH_PROFILES:-http://bbsim.voltha.svc:50074/v2/bandwidthprofiles/%s}
SADIS_CFG=${SADIS_CFG:-onos-files/onos-sadis-sample.json}
INSTALL_ONOS_APPS=${INSTALL_ONOS_APPS:-no}
JUST_K8S=${JUST_K8S:-no}
DEPLOY_K8S=${DEPLOY_K8S:-yes}
INSTALL_KUBECTL=${INSTALL_KUBECTL:-yes}
INSTALL_HELM=${INSTALL_HELM:-yes}
UPDATE_HELM_REPOS=${UPDATE_HELM_REPOS:-yes}
WAIT_ON_DOWN=${WAIT_ON_DOWN:-yes}
VOLTHA_LOG_LEVEL=${VOLTHA_LOG_LEVEL:-WARN}
VOLTHA_CHART=${VOLTHA_CHART:-onf/voltha}
VOLTHA_CHART_VERSION=${VOLTHA_CHART_VERSION:-latest}
VOLTHA_BBSIM_CHART=${VOLTHA_BBSIM_CHART:-onf/bbsim}
VOLTHA_BBSIM_CHART_VERSION=${VOLTHA_BBSIM_CHART_VERSION:-latest}
VOLTHA_ADAPTER_SIM_CHART=${VOLTHA_ADAPTER_SIM_CHART:-onf/voltha-adapter-simulated}
VOLTHA_ADAPTER_SIM_CHART_VERSION=${VOLTHA_ADAPTER_SIM_CHART_VERSION:-latest}
VOLTHA_ADAPTER_OPEN_OLT_CHART=${VOLTHA_ADAPTER_OPEN_OLT_CHART:-onf/voltha-adapter-openolt}
VOLTHA_ADAPTER_OPEN_OLT_CHART_VERSION=${VOLTHA_ADAPTER_OPEN_OLT_CHART_VERSION:-latest}
VOLTHA_ADAPTER_OPEN_ONU_CHART=${VOLTHA_ADAPTER_OPEN_ONU_CHART:-onf/voltha-adapter-openonu}
VOLTHA_ADAPTER_OPEN_ONU_CHART_VERSION=${VOLTHA_ADAPTER_OPEN_ONU_CHART_VERSION:-latest}
ONOS_CHART=${ONOS_CHART:-onf/onos}
ONOS_CHART_VERSION=${ONOS_CHART_VERSION:-latest}
EXTRA_HELM_INSTALL_ARGS=
NUM_OF_BBSIM=${NUM_OF_BBSIM:-1}
MAX_NUM_OF_BBSIM=10

HAVE_GO=$(which go >/dev/null 2>&1 && echo "yes" || echo "no")
HOSTOS=$(uname -s | tr "[:upper:]" "[:lower:"])
HOSTARCH=$(uname -m | tr "[:upper:]" "[:lower:"])
if [ $HOSTARCH == "x86_64" ]; then
    HOSTARCH="amd64"
fi

# check number (range) of bbsim, max bbsim must not exceed 10 instances!
# note: instances will be numbered from 0 to 9
if [ "$1" == "up" ]; then
    if [ "$NUM_OF_BBSIM" -lt 1 ]; then
        >&2 echo -e "${RED}${BOLD}${ERROR}ERROR:${NORMAL}${RED} Invalid setting of BBSIM instances. NUM_OF_BBSIM is less than 1${NORMAL}"
        exit 1
    fi
    if [ "$NUM_OF_BBSIM" -gt $MAX_NUM_OF_BBSIM ]; then
        >&2 echo -e "${RED}${BOLD}${ERROR}ERROR:${NORMAL}${RED} Invalid setting of BBSIM instances. NUM_OF_BBSIM is greater than $MAX_NUM_OF_BBSIM${NORMAL}"
        exit 1
    fi
fi
# Verify TYPE setting
if [ $(echo ":minimal:full:" | grep -ic ":$TYPE:") -eq 0 ]; then
    >&2 echo -e "${RED}${BOLD}${ERROR}ERROR:${NORMAL}${RED} Invalid \$TYPE value of '$TYPE'. Should be 'minimal' or 'full'${NORMAL}"
    exit 1
fi

function get_service_ep() {
    local NS=$1
    local NAME=$2
    kubectl -n $NS get service $NAME -o json | jq -r '.spec.clusterIP + ":" + (.spec.ports[0].port|tostring)'
}

# Used to verify configuration values are set to "yes" or "no" value or convert
# equivalents to "yes" or "no"
function verify_yes_no() {
    local VAR=$1
    local VAL=$(eval echo \$$VAR)
    if [ $(echo ":y:yes:true:n:no:false:1:0:" | grep -ic ":$VAL:") -eq 0 ]; then
        >&2 echo -e "${RED}${BOLD}${ERROR}ERROR:${NORMAL}${RED} Invalid '$VAR' value of '$VAL'. Should be 'yes' or 'no'${NORMAL}"
        echo "INVALID"
        return 1
    fi
    if [ $(echo ":y:yes:true:1:" | grep -ic ":$VAL:") -eq 1 ]; then
        echo "yes"
    else
        echo "no"
    fi
    return 0
}

ALL_YES_NO="\
    ENABLE_ONOS_EXTRANEOUS_RULES \
    WITH_TIMINGS \
    WITH_BBSIM \
    WITH_RADIUS \
    WITH_EAPOL \
    WITH_DHCP \
    WITH_IGMP \
    WITH_ONOS \
    WITH_SECOND_ONOS \
    WITH_CHAOS \
    WITH_ADAPTERS \
    WITH_SIM_ADAPTERS \
    WITH_OPEN_ADAPTERS \
    WITH_PORT_FORWARDS \
    JUST_K8S \
    DEPLOY_K8S \
    INSTALL_ONOS_APPS \
    INSTALL_KUBECTL \
    INSTALL_HELM \
    UPDATE_HELM_REPOS \
    WAIT_ON_DOWN \
    ONLY_ONE \
    "

ALL_OPTIONS="\
    NAME \
    TYPE \
    $ALL_YES_NO \
    VOLTHA_LOG_LEVEL \
    VOLTHA_CHART \
    VOLTHA_CHART_VERSION \
    VOLTHA_BBSIM_CHART \
    VOLTHA_BBSIM_CHART_VERSION \
    NUM_OF_BBSIM \
    VOLTHA_ADAPTER_SIM_CHART \
    VOLTHA_ADAPTER_SIM_CHART_VERSION \
    VOLTHA_ADAPTER_OPEN_OLT_CHART \
    VOLTHA_ADAPTER_OPEN_OLT_CHART_VERSION \
    VOLTHA_ADAPTER_OPEN_ONU_CHART \
    VOLTHA_ADAPTER_OPEN_ONU_CHART_VERSION \
    ONOS_CHART \
    ONOS_CHART_VERSION \
    ONOS_API_PORT \
    ONOS_SSH_PORT \
    CONFIG_SADIS \
    SADIS_CFG \
    VOLTHA_API_PORT \
    VOLTHA_SSH_PORT \
    VOLTHA_ETCD_PORT \
    VOLTHA_KAFKA_PORT \
    VK_RELEASE \
    KIND_VERSION \
    VOLTCTL_VERSION \
    "

# Iterate over yes/no configuration options and validate
for VAR in $ALL_YES_NO; do
    eval $VAR=$(verify_yes_no $VAR)
    if [ "$(eval echo \$$VAR)" == "INVALID" ]; then
        exit 1;
    fi
done

# Check for prerequiste tools
TOOLS="curl sed jq"
if [ $DEPLOY_K8S == "yes" ]; then
    TOOLS+=" docker"
fi
NOT_FOUND=""
for T in $TOOLS; do
    if [ -z "$(which $T)" ]; then
        NOT_FOUND+=" $T"
    fi
done

if [ ! -z "$NOT_FOUND" ]; then
    >&2 echo -e "${RED}${BOLD}${ERROR}ERROR:${NORMAL}${RED} The following required tools where not found, please install them:$NOT_FOUND"
    exit 1
fi

mkdir -p .voltha
touch .voltha/ports
HAVE=$(grep $NAME .voltha/ports)
if [ "$HAVE X" == " X" ]; then
    # Find free port prefix
    START=81
    while true; do
        if [ $(grep -c $START .voltha/ports) -eq 0 ]; then
            break
        fi
        START=$(expr $START + 1)
    done
    DELTA=$(expr $START - 81)
    ONOS_API_PORT=${ONOS_API_PORT:-${START}81}
    ONOS_SSH_PORT=${ONOS_SSH_PORT:-${START}01}
    VOLTHA_API_PORT=${VOLTHA_API_PORT:-5$(expr 55 + $DELTA)55}
    VOLTHA_SSH_PORT=${VOLTHA_SSH_PORT:-$(expr 50 + $DELTA)22}
    VOLTHA_ETCD_PORT=${VOLTHA_ETCD_PORT:-$(expr 23 + $DELTA)79}
    VOLTHA_KAFKA_PORT=${VOLTHA_KAFKA_PORT:-$(expr 90 + $DELTA)92}
else
    VALUES=$(echo $HAVE | sed -e 's/\s//g' | cut -d= -f2)
    ONOS_API_PORT=${ONOS_API_PORT:-$(echo $VALUES | cut -d, -f1)}
    ONOS_SSH_PORT=${ONOS_SSH_PORT:-$(echo $VALUES | cut -d, -f2)}
    VOLTHA_API_PORT=${VOLTHA_API_PORT:-$(echo $VALUES | cut -d, -f3)}
    VOLTHA_SSH_PORT=${VOLTHA_SSH_PORT:-$(echo $VALUES | cut -d, -f4)}
    VOLTHA_ETCD_PORT=${VOLTHA_ETCD_PORT:-$(echo $VALUES | cut -d, -f5)}
    VOLTHA_KAFKA_PORT=${VOLTHA_KAFKA_PORT:-$(echo $VALUES | cut -d, -f6)}

    # A bit of a hueristic required here as the KAFKA port forward was
    # added after the .voltha/ports files was created. Basically, if
    # the VOLTHA_KAFKA_PORT isn't in the file then calculate the original
    # DELTA from the VOLTHA_SSH_PORT and apply it to the VOLTHA_KAFKA_PORT
    if [ -z "$VOLTHA_KAFKA_PORT" ]; then
        DELTA=$((VOLTHA_SSH_PORT/100-50))
        VOLTHA_KAFKA_PORT=${VOLTHA_KAFKA_PORT:-$(expr 90 + $DELTA)92}
    fi
fi

PORTTMP=$(mktemp -u)
cat .voltha/ports | grep -v $NAME > $PORTTMP
echo "$NAME=$ONOS_API_PORT,$ONOS_SSH_PORT,$VOLTHA_API_PORT,$VOLTHA_SSH_PORT,$VOLTHA_ETCD_PORT,$VOLTHA_KAFKA_PORT" >> $PORTTMP
cp $PORTTMP .voltha/ports
rm -f $PORTTMP

export ONOS_API_PORT ONOS_SSH_PORT

IDX=1
CLOCK="TIME:"
SPIN_PARTS=
NOT_VERIFIED=
THEX=
BUILD=
CROSS=
ENTER=
VERIFIED=
HELM=
OLD_KEY=
BIRD=
HIGH_VOLTAGE=
PLUG=
RESTART=
FORWARD=
INSTALL=
STOP=
GO=
DOWNLOAD=
GEAR=
NO_ENTRY=
LOCK=

if [ $FANCY -eq 1 ]; then
    SPIN_PARTS="\
            \xe2\xa2\x8e\xe2\xa1\xb0 \
            \xe2\xa2\x8e\xe2\xa1\xa1 \
            \xe2\xa2\x8e\xe2\xa1\x91 \
            \xe2\xa2\x8e\xe2\xa0\xb1 \
            \xe2\xa0\x8e\xe2\xa1\xb1 \
            \xe2\xa2\x8a\xe2\xa1\xb1 \
            \xe2\xa2\x8c\xe2\xa1\xb1 \
            \xe2\xa2\x86\xe2\xa1\xb1 \
            "
    CLOCK="\xe2\x8f\xb1"
    THEX="${RED}${BOLD}\xe2\x9c\x97\x20${NORMAL}"
    ENTER="${YELLOW}${BOLD}\xe2\x8e\x86${NORMAL}"
    CROSS="${YELLOW}${BOLD}\xe2\x9c\x9a${NORMAL}"
    BUILD="${YELLOW}${BOLD}\xf0\x9f\x8f\x97${NORMAL}"
    NOT_VERIFIED="$BUILD"
    VERIFIED="${GREEN}${BOLD}\xe2\x9c\x93\x20${NORMAL}"
    HELM="${BLUE}${BOLD}\xE2\x8E\x88${NORMAL}"
    OLD_KEY="\xF0\x9F\x97\x9D"
    BIRD="\xF0\x9F\x90\xA6"
    HIGH_VOLTAGE="\xE2\x9A\xA1"
    PLUG="\xF0\x9F\xa7\xa9"
    RESTART="\xf0\x9f\x94\x84"
    FORWARD="\xE2\x87\xA8"
    INSTALL="\xF0\x9F\x8F\x97"
    STOP="\xf0\x9f\x9b\x91"
    GO="\xf0\x9f\x9a\x80"
    DOWNLOAD="\xf0\x9f\x93\xa5"
    GEAR="\xe2\x9a\x99"
    NO_ENTRY="\xe2\x9b\x94"
    LOCK="\xf0\x9f\x94\x92"
fi

duration() {
    local h=$(expr $1 / 3600)
    local m=$(expr $1 % 3600 / 60)
    local s=$(expr $1 % 60)
    local t=""

    if [ $h -gt 0 ]; then
        t="$t${h}h"
    fi
    if [ $m -gt 0 ]; then
        t="$t${m}m"
    fi
    echo "$t${s}s"
}

printtime() {
    local INDENT=
    if [ "$1" == "-" ]; then
        INDENT="  "
        shift
    fi
    echo -e "$INDENT  $CLOCK  $(duration $1)"
}

bspin() {
    IDX=1
    local INDENT=
    if [ "$1" == "-" ]; then
        INDENT="  "
        shift
    fi
    if [ $FANCY -eq 0 ]; then
        LINE=$(echo $* | sed -e 's/[\s+-]//g')
        if [ "$LINE X" == " X" ]; then
            return
        fi
        echo -e "$CIVIS$INDENT$*"
    else
        echo -en "$CIVIS$INDENT   $*"
    fi
}

sspin() {
    local INDENT=
    if [ "$1" == "-" ]; then
        INDENT="  "
        shift
    fi
    if [ $FANCY -eq 0 ]; then
        LINE=$(echo $* | sed -e 's/[\s+-]//g')
        if [ "$LINE X" == " X" ]; then
            return
        fi
        echo -e "$INDENT$*"
    else
        C=$(echo $SPIN_PARTS | cut '-d ' -f $IDX)
        echo -en "\r$INDENT$C $*"
        IDX=$(expr $IDX + 1)
        if [ $IDX -gt 8 ]; then
            IDX=1
        fi
    fi
}

espin() {
    local INDENT=
    if [ "$1" == "-" ]; then
        INDENT="  "
        shift
    fi
    if [ $FANCY -eq 0 ]; then
        LINE=$(echo $* | sed -e 's/[\s+-]//g')
        if [ "$LINE X" == " X" ]; then
            return
        fi
        echo -e "$INDENT$*"
    else
        echo -e "\r$INDENT$*$CNORM"
    fi
}

if [ "$1" == "get" -a "$2" == "voltconfig" ]; then
    echo "$HOME/.volt/config-$NAME"
    exit
fi

if [ $# -ne 1 -o $(echo ":up:down:dump:" | grep -c ":$1:") -ne 1 ]; then
    >&2 echo "What wouild you like to do today:"
    >&2 echo "  up   - bring up voltha"
    >&2 echo "  down - tear down voltha"
    >&2 echo "  dump - create a debug dump of running system"
    exit 1
fi

push_onos_config() {
    local TYPE=$1
    local MSG=$2
    local RESOURCE=$3
    local DATA=$4

    # Thanks to the latest version of ONOS using the return code 207 this gets a
    # whole lot nastier. Can't thank them enough for doing this. So in order to
    # capture the command and the output in the log file as well as capture the
    # status code to verify it is 200 and not 207 mutltiple files and a bit of
    # hackery must be used. Thanks again ONOS.
    local CMD_ECHO=$(mktemp -u)
    local CMD_OUTPUT=$(mktemp -u)
    local SC_OUTPUT=$(mktemp -u)

    bspin - "$MSG $GEAR"
    while true; do
        if [ $TYPE == "file" ]; then
            (set -x; curl --fail -sSL --user karaf:karaf -w "%{http_code}" -o $CMD_OUTPUT -X POST -H Content-Type:application/json http://$_ONOS_API_EP/onos/v1/$RESOURCE --data @$DATA >$SC_OUTPUT 2>/dev/null) >>$CMD_ECHO 2>&1
            RESULT=$?
        fi
        if [ $TYPE == "json" ]; then
            (set -x; curl --fail -sSL --user karaf:karaf -w "%{http_code}" -o $CMD_OUTPUT -X POST -H Content-Type:application/json http://$_ONOS_API_EP/onos/v1/$RESOURCE --data $DATA >$SC_OUTPUT 2>/dev/null) >>$CMD_ECHO 2>&1
            RESULT=$?
        fi
        # Dump everything to the log
        cat $CMD_ECHO >> $LOG
        test -r $CMD_OUTPUT && cat $CMD_OUTPUT >> $LOG
        SC=$(cat $SC_OUTPUT)
        echo "RESPONSE CODE: $SC" >> $LOG
        echo "ERROR CODE: $RESULT" >> $LOG

        # clean up temp files
        rm -f $CMD_ECHO $CMD_OUTPUT $SC_OUTPUT
        if [ $RESULT -eq 0 -a "$SC" == "200" ]; then
            break
        fi
        sleep 1
        sspin -
    done
    espin - $VERIFIED
}

check_onos_app_active() {
  local APP_ID=$1

  bspin - "Checking that $APP_ID is active $CLOCK"
  while true; do
      (set -x; curl --fail -sSL --user karaf:karaf -X GET http://$_ONOS_API_EP/onos/v1/applications/$APP_ID | grep ACTIVE >>$LOG 2>&1) >>$LOG 2>&1
      if [ $? -eq 0 ]; then
          break
      fi
      sleep 1
      sspin -
  done
  sleep 5 # OSGI components take a little longer that the app to activate
  espin - $VERIFIED
}

override_onos_app() {
    local APP=$1
    local NAME=$(basename $APP | sed -e 's/^[0-9][0-9]*-//g' -e 's/-.*$//g')
    while true; do
        sspin -
        # Attempt to delete old version (if it exists)
        (set -x; curl --fail -sSL --user karaf:karaf -X DELETE http://$_ONOS_API_EP/onos/v1/applications/$NAME >>$LOG 2>&1) >>$LOG 2>&1
        sspin -
        if [ $? -ne 0 ]; then
            continue
        fi
        (set -x; curl --fail -sSL --user karaf:karaf -X POST -H Content-Type:application/octet-stream http://$_ONOS_API_EP/onos/v1/applications?activate=true --data-binary @$APP >>$LOG 2>&1) >>$LOG 2>&1
        if [ $? -eq 0 ]; then
            break
        fi
        sleep .2
    done
}

activate_onos_app() {
    local MSG="$1"
    local APP=$2

    bspin - "$MSG $GO"
    while true; do
        sspin -
        (set -x; curl --fail -sSL --user karaf:karaf -X POST http://$_ONOS_API_EP/onos/v1/applications/$APP/active >>$LOG 2>&1) >>$LOG 2>&1
        if [ $? -eq 0 ]; then
            break
        fi
        sleep .2
    done
    espin - "$VERIFIED"
}

count_pods() {
    local NAMESPACE=$1; shift
    if [ "$NAMESPACE" == "all-namespaces" ]; then
        NAMESPACE="--all-namespaces"
    else
        NAMESPACE="-n $NAMESPACE"
    fi
    echo "$NAMESPACE" > /tmp/t
    local STATES=$1; shift
    echo "$STATES" >> /tmp/t
    local PODS=$(kubectl get $NAMESPACE  pod -o go-template="{{range .items}}{{.metadata.name}}/{{.status.phase}}/_{{range .status.containerStatuses}}{{.ready}}_{{end}} {{end}}")
    local COUNT=0
    local PATTERNS="$*"
    for POD in $PODS; do
        local NAME=$(echo $POD | cut -d/ -f 1)
        local STATE=$(echo $POD | cut -d/ -f 2)
        local CONTAINERS=$(echo $POD | cut -d/ -f 3 | sed -e 's/_/ /g')
        if [ "$STATES" == "*" -o $(echo "$STATES" | grep -c ":$STATE:") -ne 0 ]; then
            echo "IN WITH $POD" >> /tmp/t
            local TOTAL=$(echo $CONTAINERS | wc -w)
            local FOUND=$(echo $CONTAINERS | grep -o true | wc -l)
            if [ $TOTAL -eq $FOUND ]; then
                for PATTERN in $PATTERNS; do
                    echo "TEST $PATTERN AGAINST $NAME" >> /tmp/t
                    if [[ $NAME =~ $PATTERN ]]; then
                        echo "COUNT $NAME" >> /tmp/t
                        COUNT=$(expr $COUNT + 1)
                        break
                    fi
                done
            fi
        fi
    done
    echo $COUNT >> /tmp/t
    echo $COUNT
}

wait_for_pods() {
    local INDENT=
    if [ "$1" == "-" ]; then
        INDENT=$1; shift
    fi
    local NAMESPACE=$1; shift
    local EXPECT=$1; shift
    local TYPE=$1; shift
    local RETRY=$1; shift
    local MESSAGE=$1; shift
    local PATTERNS=$*
    local STATES=":Running:"
    if [ "$TYPE" == "not" ]; then
        STATES="*"
    fi
    local HAVE=$(count_pods $NAMESPACE "$STATES" $PATTERNS)
    local ALL=$HAVE
    if [ "$TYPE" == "only" ]; then
        ALL=$(count_pods "all-namespaces" "*" ".*")
    fi
    COUNT=$(expr 300 / 15)
    bspin $INDENT $MESSAGE
    sspin $INDENT
    if [ $HAVE -ne $EXPECT -o $ALL -ne $HAVE ]; then
        while [ $HAVE -ne $EXPECT -o $ALL -ne $HAVE ]; do
            sspin $INDENT
            COUNT=$(expr $COUNT - 1)
            if [ $COUNT -eq 0 ]; then
                HAVE=$(count_pods $NAMESPACE "$STATES" $PATTERNS)
                ALL=$HAVE
                if [ "$TYPE" == "only" ]; then
                    ALL=$(count_pods "all-namespaces" "*" ".*")
                fi
                COUNT=$(expr 300 / 15)
            fi
            sleep .15
        done
    fi
    espin $INDENT $VERIFIED
    if [ $HAVE -ne $EXPECT ]; then
        return 1
    fi
    return 0
}

port_forward() {
    local NS=$1
    local SVC=$2
    local FROM_PORT=$3
    local TO_PORT=$4
    local TAG=$SVC-$NAME

    (set -x; _TAG=$TAG bash -c "while true; do kubectl port-forward --address 0.0.0.0 -n $NS service/$SVC $FROM_PORT:$TO_PORT; done" >>$LOG 2>&1 &) >>$LOG 2>&1
}

kill_port_forward() {
    local TAG=$1-$NAME
    local P_IDS=$(ps e -ww -A | grep "_TAG=$TAG" | grep -v grep | awk '{print $1}')
    local PARENTS=
    local KIDS=
    local UNKNOWN=
    if [ ! -z "$P_IDS" ]; then
        for P_ID in $P_IDS; do
            local PP_ID=$(ps -o ppid $P_ID | tail -n +2)
            if [ ! -z "$PP_ID" ]; then
                if [ $PP_ID -eq 1 ]; then
                    PARENTS="$PARENTS $P_ID"
                else
                    KIDS="$KIDS $P_ID"
                fi
            else
                UNKNOWN="$UNKNOWN $P_ID"
            fi
        done
        (set -x; kill -9 $PARENTS $KIDS $UNKNOWN >>$LOG 2>&1) >>$LOG 2>&1
    fi
}

if [ "$1" == "down" ]; then
    echo "Tearing down voltha cluster $NAME"
    LOG="down-$NAME.log"
    echo $(date -u +"%Y%m%dT%H%M%SZ") >$LOG
    bspin "Remove port-forwards: onos-ui-$NAME"
    kill_port_forward onos-ui
    sspin "Remove port-forwards: onos-ssh-$NAME$CEOL"
    kill_port_forward onos-ssh
    sspin "Remove port-forwards: voltha-api-$NAME$CEOL"
    kill_port_forward voltha-api
    sspin "Remove port-forwards: voltha-etcd-$NAME$CEOL"
    kill_port_forward voltha-etcd-cluster-client
    sspin "Remove port-forwards: voltha-kafka-$NAME$CEOL"
    kill_port_forward voltha-kafka
    espin "$VERIFIED Remove port-forwards$CEOL"
    if [ $DEPLOY_K8S == "yes" ]; then
        if [ -x ./bin/kind ]; then
            bspin "Delete Kubernetes Kind Cluster"
            (set -x; ./bin/kind delete cluster --name voltha-$NAME >>$LOG 2>&1) >>$LOG 2>&1
            espin $VERIFIED
        else
            espin "$NO_ENTRY Delete Kubernetes Kind Cluster: kind command not found"
        fi
    else
        EXISTS=$(helm list -q)
        EXPECT="etcd-operator onos open-olt open-onu sim voltha bbsim radius"
        bspin "Remove Helm Deployments"
        for i in $EXISTS; do
            for j in $EXPECT; do
                if [[ $i =~ $j ]]; then
                    sspin "Remove Helm Deployments: $i$CEOL"
                    (set -x; ./bin/helm delete --no-hooks --purge $i >>$LOG 2>&1) >>$LOG 2>&1
                fi
            done
        done
        espin "$VERIFIED Remove Helm Deployments$CEOL"
        if [ "$WAIT_ON_DOWN" == "yes" ]; then
            # There should only be 13 or 15 PODs in the kube-system name
            # space and no other PODs
            PODS="coredns-.* \
                etcd-voltha-$NAME-control-plane \
                kindnet-.* \
                kube-apiserver-voltha-$NAME-control-plane \
                kube-controller-manager-voltha-$NAME-control-plane \
                kube-proxy-.* \
                kube-scheduler-voltha-$NAME-control-plane \
                tiller-deploy-.*"
            EXPECT=$(test "$TYPE" == "minimal" && echo "13" || echo "15")
            PODS="adapter-.* \
                bbsim.* \
                etcd-operator.* \
                radius.* \
                voltha-.*"

            EXPECT=0

            if [ "$WITH_ONOS" == "yes" ]; then
              ONOS_PODS="onos-.*"
              wait_for_pods "default" $EXPECT "not" -1 "Waiting for ONOS PODs to terminate" $ONOS_PODS
            fi
            wait_for_pods "voltha" $EXPECT "not" -1 "Waiting for VOLTHA PODs to terminate" $PODS
        fi
    fi
    exit
fi

if [ "$1" == "dump" ]; then
    LOG="dump-$NAME.log"
    TS=$(date -u +"%Y%m%dT%H%M%SZ")
    if [ ! -z "$DUMP_FROM" ]; then
        TS=$(echo $DUMP_FROM | sed -e 's/[:-]//g')
    fi
    WORK=$(mktemp -u -d)
    DATA=$WORK/voltha-debug-dump-$NAME-$TS
    mkdir -p $DATA
    echo $TS > $LOG
    echo -e "Capturing debug dump to voltha-debug-dump-$NAME-$TS.tgz"
    bspin - "Copy install log"
    if [ -f install-$NAME.log ]; then
        (set -x; cp install-$NAME.log $DATA/install-$NAME.log) >>$LOG 2>&1
        espin - $VERIFIED
    else
        espin - "$NO_ENTRY Copy install log: install-$NAME.log not found"
    fi
    bspin - "Dumping Kubernetes PODs"
    (set -x; kubectl get --all-namespaces pods >> $DATA/all-pods.txt 2>&1) >>$LOG 2>&1
    espin - $VERIFIED
    bspin - "Dumping Kubernetes SERVICEs"
    (set -x; kubectl get --all-namespaces svc >> $DATA/all-services.txt 2>&1) >>$LOG 2>&1
    espin - $VERIFIED
    bspin - "Dumping Kubernetes EVENTs"
    (set -x; kubectl get --all-namespaces events >> $DATA/all-events.txt 2>&1) >>$LOG 2>&1
    espin - $VERIFIED
    bspin - "Dumping VOLTHA POD details"
    PODS="$(kubectl -n default get pod -o name | grep onos | sed -e 's/^/default:/g') $(kubectl get -n voltha pod -o name | sed -e 's/^/voltha:/g')"
    SINCE=
    if [ ! -z "$DUMP_FROM" ]; then
        SINCE="--since-time=$DUMP_FROM"
    fi
    for POD in $PODS; do
        NS=$(echo $POD | cut -d: -f1)
        POD=$(echo $POD | cut -d: -f2)
        sspin - "Dumping VOLTHA POD details: $POD$CEOL"
        mkdir -p $DATA/$POD
        (set -x; kubectl describe -n $NS $POD >> $DATA/$POD/describe.txt 2>&1) >>$LOG 2>&1
        sspin - "Dumping VOLTHA POD details: $POD"
        (set -x; kubectl logs -n $NS --all-containers $SINCE --previous $LOG_ARGS $POD >> $DATA/$POD/logs-previous.txt 2>&1) >>$LOG 2>&1
        sspin - "Dumping VOLTHA POD details: $POD"
        (set -x; kubectl logs -n $NS --all-containers $SINCE $LOG_ARGS $POD >> $DATA/$POD/logs-current.txt 2>&1) >>$LOG 2>&1
        sspin - "Dumping VOLTHA POD details: $POD"
    done
    espin - "$VERIFIED Dumping VOLTHA POD details$CEOL"
    bspin - "Dumping ETCD"
    if [ "$(which etcdctl) X" != " X" ]; then
        (set -x; ETCDCTL_API=3 etcdctl --endpoints localhost:$VOLTHA_ETCD_PORT get --prefix service/voltha | hexdump -C >> $DATA/etcd.hex 2>&1) >>$LOG 2>&1
        espin - $VERIFIED
    else
        espin - "$NO_ENTRY Dumping ETCD: etcdctl command not available"
    fi
    bspin - "Creating compressed TAR: voltha-debug-dump-$NAME-$TS.tgz"
    (set -x; tar -C $WORK -zcf voltha-debug-dump-$NAME-$TS.tgz ./voltha-debug-dump-$NAME-$TS) >>$LOG 2>&1
    espin - $VERIFIED
    bspin - "Cleanup"
    (set -x; rm -rf $WORK) >>$LOG 2>&1
    espin - $VERIFIED
    bspin - "$(ls -l voltha-debug-dump-$NAME-$TS.tgz)"
    espin - $VERIFIED
    exit
fi

LOG="install-$NAME.log"
date > $LOG
echo "PORTS=$ONOS_API_PORT,$ONOS_SSH_PORT,$VOLTHA_API_PORT,$VOLTHA_SSH_PORT,$VOLTHA_ETCD_PORT" >> $LOG

# Output install options to log
echo "OPTIONS" >> $LOG
for O in $ALL_OPTIONS; do
    VAL=$(eval echo \$$O)
    if [ ! -z "$VAL" ]; then
        printf "    %-30s = %s\n" $O $VAL >> $LOG
    fi
done

helm_install() {
    local INDENT=
    if [ "$1" == "-" ]; then
        INDENT=$1; shift
    fi
    local NAMESPACE=$1; shift
    local INAME=$1; shift
    local CHART=$1; shift
    local CHART_VERSION=$1; shift
    local MESSAGE=$*

    if [ "$CHART_VERSION X" != " X" -a "$CHART_VERSION" != "latest" ]; then
        CHART_VERSION="--version $CHART_VERSION"
    else
        CHART_VERSION=
    fi

    local CHART_ARGS=
    if [ -r "${INAME}-values.yaml" ]; then
        CHART_ARGS="-f ${INAME}-values.yaml"
    fi

    COUNT=$(expr 300 / 15)
    bspin $INDENT $MESSAGE
    (set -x; helm install -f $NAME-values.yaml $CHART_ARGS $EXTRA_HELM_INSTALL_ARGS --set defaults.log_level=$VOLTHA_LOG_LEVEL --namespace $NAMESPACE --name $INAME $CHART_VERSION $EXTRA_HELM_FLAGS $CHART >>$LOG 2>&1) >>$LOG 2>&1
    SUCCESS=$?
    while [ $SUCCESS -ne 0 ]; do
        sspin $INDENT
        COUNT=$(expr $COUNT - 1)
        if [ $COUNT -eq 0 ]; then
            (set -x; helm delete --purge $INAME >>$LOG 2>&1) >>$LOG 2>&1
            (set -x; helm install -f $NAME-values.yaml $CHART_ARGS --set defaults.log_level=$VOLTHA_LOG_LEVEL --namespace $NAMESPACE --name $INAME $CHART_VERSION $EXTRA_HELM_FLAGS $CHART >>$LOG 2>&1) >>$LOG 2>&1
            SUCCESS=$?
            COUNT=$(expr 300 / 15)
        fi
        sleep .15
    done
    espin $INDENT $VERIFIED
}

echo "INSTALL TYPE: $TYPE" >> $LOG

bspin "Verify GOPATH"
export GOPATH=$(pwd)
mkdir -p $GOPATH/bin
espin $VERIFIED

STIME=$(date +%s)
if [ "$INSTALL_KUBECTL" == "no" ]; then
    bspin "Skip kubectl install"
    espin $NO_ENTRY
else
    bspin "Verify kubectl $HELM"
    if [ -x $GOPATH/bin/kubectl ]; then
        espin $VERIFIED
    else
        espin $NOT_VERIFIED
        bspin - "Download and install Kubernetes/kubectl $DOWNLOAD"
        (set -x; curl -o $GOPATH/bin/kubectl -sSL https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/$HOSTOS/$HOSTARCH/kubectl >>$LOG 2>&1) >>$LOG 2>&1
        (set -x; chmod 755 $GOPATH/bin/kubectl >>$LOG 2>&1) >>$LOG 2>&1
        espin - $VERIFIED
    fi
fi
if [ "$WITH_TIMINGS" == "yes" ]; then
    printtime $(expr $(date +%s) - $STIME)
fi

STIME=$(date +%s)
if [ "$DEPLOY_K8S" == "no" ]; then
    bspin "Skip Kubernetes/Kind Deployment"
    espin $NO_ENTRY
else
    bspin "Verify Kubernetes/Kind $HELM"
    IS_INSTALLED=0
    OP_TYPE="install"
    if [ -x $GOPATH/bin/kind ]; then
        OP_TYPE="upgrade"
        if [ $($GOPATH/bin/kind --version | grep -c $KIND_VERSION) -eq 1 ]; then
            IS_INSTALLED=1
            espin $VERIFIED
        fi
    fi
    if [ $IS_INSTALLED -eq 0 ]; then
        espin $NOT_VERIFIED
        bspin - "Download and $OP_TYPE Kubernetes/kind $DOWNLOAD"
        (set -x; curl -o $GOPATH/bin/kind -sSL https://github.com/kubernetes-sigs/kind/releases/download/$KIND_VERSION/kind-$HOSTOS-$HOSTARCH >>$LOG 2>&1) >>$LOG 2>&1
        (set -x; chmod 755 $GOPATH/bin/kind >>$LOG 2>&1) >>$LOG 2>&1
        espin - $VERIFIED
    fi
fi

if [ "$WITH_TIMINGS" == "yes" ]; then
    printtime $(expr $(date +%s) - $STIME)
fi

STIME=$(date +%s)
if [ "$INSTALL_HELM" == "no" ]; then
    bspin "Skip Helm Install"
    espin $NO_ENTRY
else
    bspin "Verify Helm $HELM"
    if [ -x $GOPATH/bin/helm ]; then
        espin $VERIFIED
    else
        espin $NOT_VERIFIED
        bspin - "Download and install Helm $DOWNLOAD"
        (set -x; curl -sSL https://git.io/get_helm.sh | DESIRED_VERSION=v2.14.3  USE_SUDO=false HELM_INSTALL_DIR=$GOPATH/bin bash >>$LOG 2>&1) >>$LOG 2>&1
        espin - $VERIFIED
    fi
fi

if [ "$WITH_TIMINGS" == "yes" ]; then
    printtime $(expr $(date +%s) - $STIME)
fi

STIME=$(date +%s)
bspin "Verify voltctl $HIGH_VOLTAGE"
VOK=0
VMESSAGE="install"
export VC_VERSION="$VOLTCTL_VERSION"
if [ "$VC_VERSION" == "latest" ]; then
    export VC_VERSION=$(curl -sSL https://api.github.com/repos/opencord/voltctl/releases/latest | jq -r .tag_name | sed -e 's/^v//g')
fi
if [ -x $GOPATH/bin/voltctl ]; then
    VHAVE=$($GOPATH/bin/voltctl version --clientonly -o json | jq -r .version)
    if [ $? -eq 0 -a "$VHAVE" == "$VC_VERSION" ]; then
        VOK=1
        espin $VERIFIED
    else
        VCHECK=$(echo -e "$VHAVE\n$VC_VERSION" | sort -V | head -1)
        if [ "$VCHECK" == "$VHAVE" ]; then
            VMESSAGE="upgrade"
        else
            VMESSAGE="downgrade"
        fi
    fi
fi

if [ $VOK -eq 0 ]; then
    espin $NOT_VERIFIED
    bspin - "Download and $VMESSAGE voltctl $DOWNLOAD"
    (set -x; curl -o $GOPATH/bin/voltctl -sSL https://github.com/opencord/voltctl/releases/download/v$VC_VERSION/voltctl-$VC_VERSION-$HOSTOS-$HOSTARCH >>$LOG 2>&1) >>$LOG 2>&1
    (set -x; chmod 755 $GOPATH/bin/voltctl >>$LOG 2>&1) >>$LOG 2>&1
    espin - $VERIFIED
fi
if [ "$WITH_TIMINGS" == "yes" ]; then
    printtime $(expr $(date +%s) - $STIME)
fi

bspin "Verify command PATH"
export PATH=$GOPATH/bin:$PATH
espin $VERIFIED

STIME=$(date +%s)
if [ "$DEPLOY_K8S" == "yes" ]; then
    HAVE=$(kind get clusters | grep -c voltha-$NAME)
    bspin "Verify Kubernetes/Kind Cluster"
    sspin
    if [ $HAVE -eq 0 ]; then
        espin $NOT_VERIFIED
        bspin - "Verify cluster configuration"
        if [ ! -r ./$NAME-cluster.cfg ]; then
            espin - $NOT_VERIFIED
            bspin - "Download cluster configuration: $TYPE-cluster.cfg to $NAME-cluster.cfg $DOWNLOAD"
            ERR_OUT=$(mktemp)
            (set -x; curl --fail -o ./$NAME-cluster.cfg -sSL https://raw.githubusercontent.com/ciena/kind-voltha/$VK_RELEASE/$TYPE-cluster.cfg >>$LOG 2>>$ERR_OUT) >>$LOG 2>&1
            if [ $? -ne 0 ]; then
                espin - $THEX
                echo -e "${RED}${BOLD}${ERROR}ERROR: $NAME-cluster.cfg${NORMAL}${RED} - $(cat $ERR_OUT)${NORMAL}"
                echo "ERROR: $(cat $ERR_OUT)" >>$LOG
                rm -rf $ERR_OUT ./$NAME-cluster.cfg
                exit 1
            fi
            rm -rf $ERR_OUT
        else
            espin - $VERIFIED
        fi
        kind create cluster --name voltha-$NAME --config $NAME-cluster.cfg
     else
        espin $VERIFIED
    fi

    export KUBECONFIG="$(kind get kubeconfig-path --name="voltha-$NAME" | tail -n1)"
    P="coredns-.* \
        etcd-voltha-$NAME-control-plane \
        kindnet-.* \
        kube-apiserver-voltha-$NAME-control-plane \
        kube-controller-manager-voltha-$NAME-control-plane \
        kube-proxy-.* \
        kube-scheduler-voltha-$NAME-control-plane"

    EXPECT=$(test "$TYPE" == "minimal" && echo "12" || echo "14")
    wait_for_pods - "kube-system" $EXPECT "includes" -1 "Waiting for system PODs to start" $P
fi
if [ "$WITH_TIMINGS" == "yes" ]; then
    printtime $(expr $(date +%s) - $STIME)
fi

STIME=$(date +%s)
COUNT=$(count_pods "kube-system" ":Running:" "tiller-deploy-.*")
bspin "Verify Helm"
if [ $COUNT -ne 1 ]; then
    espin $NOT_VERIFIED
    echo -e "Configuring Helm $GEAR"
    if [ "$INSTALL_HELM" == "no" ]; then
        bspin - "Skip Helm/Tiller Initialization"
        espin - $NO_ENTRY
    else
        bspin - "Initialize Helm"
        (set -x; helm init --upgrade >>$LOG 2>&1) >>$LOG 2>&1
        espin - $VERIFIED
        wait_for_pods - "kube-system" 1 "includes" -1 "Waiting for Tiller POD to start" "tiller-deploy-.*"
    fi
    bspin - "Add Google Incubator repository to Helm"
    (set -x; helm repo add incubator https://kubernetes-charts-incubator.storage.googleapis.com >>$LOG 2>&1) >>$LOG 2>&1
    espin - $VERIFIED

    # HACK (sort-of) - the config for tiller is about to be patched, which will
    # cause the tiller pod to be recreated. This can sometimes cause a timing
    # issue with the "wait_for_pods" call on tiller as it may incorrectly
    # identify the running/ready tiller pod that is soon to be terminated as
    # what it is waiting for. To avoid this issue we do a clean scale down and
    # scale up of the pod so the script controlls when it should be expecting
    # things
    (set -x; kubectl -n kube-system scale deploy tiller-deploy --replicas=0 >>$LOG 2>&1) >>$LOG 2>&1

    bspin - "Add Google Stable repository to Helm"
    (set -x; helm repo add stable https://kubernetes-charts.storage.googleapis.com >>$LOG 2>&1) >>$LOG 2>&1
    espin - $VERIFIED
    bspin - "Add ONF repository to Helm"
    (set -x; helm repo add onf https://charts.opencord.org >>$LOG 2>&1) >>$LOG 2>&1
    espin - $VERIFIED
    bspin - "Update Helm repository cache"
    (set -x; helm repo update >>$LOG 2>&1) >>$LOG 2>&1
    espin - $VERIFIED

    # Create and k8s service account so that Helm can create pods
    bspin - "Create Tiller ServiceAccount"
    (set -x; kubectl create serviceaccount --namespace kube-system tiller >>$LOG 2>&1) >>$LOG 2>&1
    espin - $VERIFIED
    bspin - "Create Tiller ClusterRoleBinding"
    (set -x; kubectl create clusterrolebinding tiller-cluster-rule --clusterrole=cluster-admin --serviceaccount=kube-system:tiller >>$LOG 2>&1) >>$LOG 2>&1
    espin - $VERIFIED
    bspin - "Update Tiller Manifest"
    (set -x; kubectl patch deploy --namespace kube-system tiller-deploy -p '{"spec":{"template":{"spec":{"serviceAccount":"tiller"}}}}' >>$LOG 2>&1) >>$LOG 2>&1

    # HACK (sort-of) - part to, spin it back up
    (set -x; kubectl -n kube-system scale deploy tiller-deploy --replicas=1 >>$LOG 2>&1) >>$LOG 2>&1
    espin - $VERIFIED
else
    espin $VERIFIED
    if [ "$UPDATE_HELM_REPOS" == "yes" ]; then
        bspin - "Update Helm repository cache"
        (set -x; helm repo update >>$LOG 2>&1) >>$LOG 2>&1
        espin - $VERIFIED
    fi
fi
wait_for_pods - "kube-system" 1 "includes" -1 "Waiting for Tiller POD to start" "tiller-deploy-.*"
if [ "$WITH_TIMINGS" == "yes" ]; then
    printtime $(expr $(date +%s) - $STIME)
fi

STIME=$(date +%s)
bspin "Verify Helm values file: $NAME-values.yaml"
if [ ! -r "./$NAME-values.yaml" ]; then
    espin $NOT_VERIFIED
    bspin - "Download Helm values file: $TYPE-values.yaml to $NAME-values.yaml $DOWNLOAD"
    ERR_OUT=$(mktemp)
    (set -x; curl --fail -o ./$NAME-values.yaml -sSL https://raw.githubusercontent.com/ciena/kind-voltha/$VK_RELEASE/$TYPE-values.yaml >>$LOG 2>$ERR_OUT) >>$LOG 2>&1
    if [ $? -ne 0 ]; then
        espin - $THEX
        echo -e "${RED}${BOLD}${ERROR}ERROR: $NAME-values.yaml${NORMAL}${RED} - $(cat $ERR_OUT)${NORMAL}"
        echo "ERROR: $(cat $ERR_OUT)" >>$LOG
        rm -rf $ERR_OUT ./$NAME-values.yaml
        exit 1
    fi
    rm -rf $ERR_OUT
    espin - $VERIFIED
else
    espin $VERIFIED
fi
if [ "$WITH_TIMINGS" == "yes" ]; then
    printtime $(expr $(date +%s) - $STIME)
fi

STIME=$(date +%s)
bspin "Verify or download chart specific values files $DOWNLOAD"
VALUES_FILES="monkey-values.yaml"
ERR_OUT=$(mktemp)
for i in $VALUES_FILES; do
    if [ ! -r ./$i ]; then
        (set -x; curl --fail -o ./$i -sSL https://raw.githubusercontent.com/ciena/kind-voltha/$VK_RELEASE/$i >>$LOG 2>$ERR_OUT) >>$LOG 2>&1
        if [ $? -ne 0 ]; then
            espin $THEX
            echo -e "${RED}${BOLD}${ERROR}ERROR: $i${NORMAL}${RED} - $(cat $ERR_OUT)${NORMAL}"
            echo "ERROR: $i - $(cat $ERR_OUT)" >>$LOG
            rm -rf $ERR_OUT ./$i
            exit 1
        fi
        rm -rf $ERR_OUT
    fi
done
espin $VERIFIED
if [ "$WITH_TIMINGS" == "yes" ]; then
    printtime $(expr $(date +%s) - $STIME)
fi

if [ "$WITH_CHAOS" == "yes" ]; then
    bspin "Verify or clone kube-monkey helm chart $DOWNLOAD"
    if [ -r ./kube-monkey ]; then
        espin $VERIFIED
    else
        espin $NOT_VERIFIED
        bspin - "GIT clone kube-monkey"
        (set -x; git clone https://github.com/asobti/kube-monkey kube-monkey >>$LOG 2>&1) >>$LOG 2>&1
        espin - $VERIFIED
    fi
fi

if [ "$JUST_K8S" == "yes" ]; then
    echo "Environment deployed, not deploying VOLTHA artifacts as requested. Good bye."
    echo ""
    echo "Please issue the following commands in your terminal to ensure that you" | tee -a $LOG
    echo "are accessing the correct Kubernetes/Kind cluster as well as have the  " | tee -a $LOG
    echo "tools required by VOLTHA in your command path.                         " | tee -a $LOG
    echo "" | tee -a $LOG
    echo -en $BOLD
    if [ $DEPLOY_K8S == "yes" ]; then
        echo "export KUBECONFIG=\"\$(./bin/kind get kubeconfig-path --name=\"voltha-$NAME\")\"" | tee -a $LOG
    fi
    echo "export PATH=$GOPATH/bin:\$PATH" | tee -a $LOG
    echo -en $NORMAL
    echo "" | tee -a $LOG
    echo "Thank you for choosing kind-voltha for you quick cluster needs." | tee -a $LOG
    exit 0
fi

STIME=$(date +%s)
bspin "Verify ETCD Operator $OLD_KEY"
if [ $(helm list --deployed --short --namespace voltha "^etcd-operator\$" | wc -l) -ne 1 ]; then
    espin $NOT_VERIFIED
    helm_install - voltha etcd-operator stable/etcd-operator latest "Install ETCD Operator"
else
    espin $VERIFIED
fi
EXPECT=$(test "$TYPE" == "minimal" && echo "1" || echo "3")
wait_for_pods - "voltha" $EXPECT "includes" -1 "Waiting for ETCD Operator to start" "etcd-operator-.*"
if [ "$WITH_TIMINGS" == "yes" ]; then
    printtime $(expr $(date +%s) - $STIME)
fi

STIME=$(date +%s)
if [ $WITH_ONOS == "yes" ]; then
    bspin "Verify ONOS installed $BIRD"
    if [ $(helm list --deployed --short --namespace default "^onos\$" | wc -l) -ne 1 ]; then
        espin $NOT_VERIFIED
        EXTRA_HELM_FLAGS="$SET_TAG $EXTRA_HELM_FLAGS" helm_install - default onos $ONOS_CHART $ONOS_CHART_VERSION "Install ONOS"
    else
        espin $VERIFIED
    fi
    wait_for_pods - "default" 1 "includes" -1 "Waiting for ONOS to start" "onos-.*"

    if [ $WITH_PORT_FORWARDS == "yes" ]; then
        bspin - "Forward ONOS API port $FORWARD"
        kill_port_forward onos-ui
        port_forward default onos-ui $ONOS_API_PORT 8181
        espin - $VERIFIED
        bspin - "Forward ONOS OPENFLOW port $FORWARD"
        kill_port_forward onos-openflow
        port_forward default onos-openflow 6653 6653
        espin - $VERIFIED
        bspin - "Forward ONOS SSH port $FORWARD"
        kill_port_forward onos-ssh
        port_forward default onos-ssh $ONOS_SSH_PORT 8101
        espin - $VERIFIED
        _ONOS_API_EP="127.0.0.1:$ONOS_API_PORT"
    else
        _ONOS_API_EP=$(get_service_ep default onos-ui)
    fi
    bspin - "Verify or download ONOS configuration support files $DOWNLOAD"
    ONOS_FILES="olt-onos-enableExtraneousRules.json onos-aaa.json \
        onos-dhcpl2relay.json onos-kafka.json onos-sadis-sample.json"
    (set -x; mkdir -p ./onos-files  >>$LOG 2>&1) >>$LOG 2>&1
    ERR_OUT=$(mktemp)
    for i in $ONOS_FILES; do
        if [ ! -r ./onos-files/$i ]; then
            (set -x; curl --fail -o ./onos-files/$i -sSL https://raw.githubusercontent.com/ciena/kind-voltha/$VK_RELEASE/onos-files/$i >>$LOG 2>$ERR_OUT) >>$LOG 2>&1
            if [ $? -ne 0 ]; then
                espin - $THEX
                echo -e "${RED}${BOLD}${ERROR}ERROR: $i${NORMAL}${RED} - $(cat $ERR_OUT)${NORMAL}"
                echo "ERROR: $(cat $ERR_OUT)" >>$LOG
                rm -rf $ERR_OUT ./onos-files/$i
                exit 1
            fi
            rm -rf $ERR_OUT
        fi
    done
    espin - $VERIFIED

    if [ $INSTALL_ONOS_APPS == "yes" ]; then
        bspin - "Installing custom ONOS applications"
        if [ -x onos-files/onos-apps -a $(ls -1 onos-files/onos-apps/*.oar 2>/dev/null | wc -l) -gt 0 ];  then
            for OAR in $(ls -1 onos-files/onos-apps/*.oar); do
                sspin - "Installing custom ONOS applications - $OAR$CEOL"
                override_onos_app $OAR
            done
            espin - "$VERIFIED Installing custom ONOS applications$CEOL"
        else
            espin - "$NOT_VERIFIED Installing custom ONOS applications - None Found"
        fi
    fi
fi

#STIME=$(date +%s)
#if [ $WITH_SECOND_ONOS == "yes" ]; then
    #bspin "Verify ONOS Fabric installed $BIRD"
    #if [ $(helm list --deployed --short --namespace default "^onos2\$" | wc -l) -ne 1 ]; then
        #espin $NOT_VERIFIED
        #EXTRA_HELM_FLAGS="$SET_TAG $EXTRA_HELM_FLAGS" helm_install - default onos onf/onos $ONOS_CHART_VERSION "Install ONOS"
    #else
        #espin $VERIFIED
    #fi
    #wait_for_pods - "default" 1 "includes" -1 "Waiting for ONOS to start" "onos-.*"

    #bspin - "Forward ONOS API port $FORWARD"
    #kill_port_forward onos-ui
    #port_forward default onos-ui 8182 8181
    #espin - $VERIFIED
    #bspin - "Forward ONOS SSH port $FORWARD"
    #kill_port_forward onos-ssh
    #port_forward default onos-ssh 8102 8101
    #espin - $VERIFIED
    #bspin - "Verify or download ONOS configuration support files $DOWNLOAD"
    #ONOS_FILES="olt-onos-enableExtraneousRules.json  olt-onos-olt-settings.json onos-aaa.json \
       # onos-dhcpl2relay.json onos-kafka.json onos-sadis-sample.json"
    #(set -x; mkdir -p ./onos-files  >>$LOG 2>&1) >>$LOG 2>&1
    #ERR_OUT=$(mktemp)
    #for i in $ONOS_FILES; do
        #if [ ! -r ./onos-files/$i ]; then
            #(set -x; curl --fail -o ./onos-files/$i -sSL https://raw.githubusercontent.com/ciena/kind-voltha/$VK_RELEASE/onos-files/$i >>$LOG 2>$ERR_OUT) >>$LOG 2>&1
            #if [ $? -ne 0 ]; then
                #espin - $THEX
                #echo -e "${RED}${BOLD}${ERROR}ERROR: $i${NORMAL}${RED} - $(cat $ERR_OUT)${NORMAL}"
                #echo "ERROR: $(cat $ERR_OUT)" >>$LOG
                #rm -rf $ERR_OUT ./onos-files/$i
                #exit 1
            #fi
            #rm -rf $ERR_OUT
        #fi
    #done
    #espin - $VERIFIED

    #if [ $INSTALL_ONOS_APPS == "yes" ]; then
        #bspin - "Installing custom ONOS applications"
        #if [ -x onos-files/onos-apps -a $(ls -1 onos-files/onos-apps/*.oar 2>/dev/null | wc -l) -gt 0 ];  then
            #for OAR in $(ls -1 onos-files/onos-apps/*.oar); do
                #sspin - "Installing custom ONOS applications - $OAR$CEOL"
                #override_onos_app $OAR
            #done
            #espin - "$VERIFIED Installing custom ONOS applications$CEOL"
        #else
            #espin - "$NOT_VERIFIED Installing custom ONOS applications - None Found"
        #fi
    #fi

    #push_onos_config "Push ONOS Kafka Configuration" "network/configuration/apps/org.opencord.kafka" "onos-files/onos-kafka.json"
    #push_onos_config "Push ONOS DHCP L2 Relay Configuration" "network/configuration/apps/org.opencord.dhcpl2relay" "onos-files/onos-dhcpl2relay.json"
    #push_onos_config "Enable VOLTHA ONOS DHCP provisioning" "configuration/org.opencord.olt.impl.Olt" "onos-files/olt-onos-olt-settings.json"
    #push_onos_config "Enabling extraneous rules for ONOS" "configuration/org.onosproject.net.flow.impl.FlowRuleManager" "onos-files/olt-onos-enableExtraneousRules.json"
    #if [ -f onos-files/onos-sadis.json ]; then
        #push_onos_config "[optional] Push ONOS SADIS Configuration" "network/configuration/apps/org.opencord.sadis" "onos-files/onos-sadis.json"
    #elif [ "$CONFIG_SADIS" == "yes" ]; then
        #SADIS_CFG=onos-files/onos-sadis-sample.json
        #push_onos_config "[optional] Push ONOS SADIS Configuration" "network/configuration/apps/org.opencord.sadis" "$SADIS_CFG"
    #fi
#fi



if [ "$WITH_TIMINGS" == "yes" ]; then
    printtime $(expr $(date +%s) - $STIME)
fi

STIME=$(date +%s)
bspin "Verify VOLTHA installed $HIGH_VOLTAGE"
if [ $(helm list --deployed --short --namespace voltha "^voltha\$" | wc -l) -ne 1 ]; then
    espin $NOT_VERIFIED
    if [ "$ONLY_ONE" == "yes" ]; then
        EXTRA_HELM_INSTALL_ARGS="--set therecanbeonlyone=true"
    fi
    helm_install - voltha voltha $VOLTHA_CHART $VOLTHA_CHART_VERSION "Install VOLTHA Core"
    EXTRA_HELM_INSTALL_ARGS=
else
    espin $VERIFIED
fi

VOLTHA="voltha-ofagent-.* \
    ro-core.* \
    rw-core.* \
    voltha-api-server-.* \
    voltha-etcd-cluster-.* \
    voltha-kafka-.* \
    voltha-zookeeper-.*"
if [ "$ONLY_ONE" == "yes" ]; then
    EXPECT=$(test "$TYPE" == "minimal" && echo "5" || echo "7")
else
    EXPECT=$(test "$TYPE" == "minimal" && echo "8" || echo "10")
fi
wait_for_pods - "voltha" $EXPECT "includes" -1 "Waiting for VOLTHA Core to start" $VOLTHA
if [ "$WITH_TIMINGS" == "yes" ]; then
    printtime $(expr $(date +%s) - $STIME)
fi

if [ "$WITH_ADAPTERS" == "yes" ]; then
    STIME=$(date +%s)
    EXPECT=0
    echo -e "Verify Adapters $PLUG"
    if [ "$WITH_SIM_ADAPTERS" == "yes" ]; then
        bspin - "Verify Simulated Adapters installed"
        if [ $(helm list --deployed --short --namespace voltha "^sim\$" | wc -l) -ne 1 ]; then
            espin - $NOT_VERIFIED
            helm_install - voltha sim $VOLTHA_ADAPTER_SIM_CHART $VOLTHA_ADAPTER_SIM_CHART_VERSION "Install Simulated Adapters"
        else
            espin - $VERIFIED
        fi
        EXPECT=$(expr $EXPECT + 2)
    fi

    if [ "$WITH_OPEN_ADAPTERS" == "yes" ]; then
        bspin - "Verify OpenOLT Adapter installed"
        if [ $(helm list --deployed --short --namespace voltha "^open-olt\$" | wc -l) -ne 1 ]; then
            espin - $NOT_VERIFIED
            helm_install - voltha open-olt $VOLTHA_ADAPTER_OPEN_OLT_CHART $VOLTHA_ADAPTER_OPEN_OLT_CHART_VERSION "Install OpenOLT Adapter"
        else
            espin - $VERIFIED
        fi
        bspin - "Verify OpenONU Adapter installed"
        if [ $(helm list --deployed --short --namespace voltha "^open-onu\$" | wc -l) -ne 1 ]; then
            espin - $NOT_VERIFIED
            helm_install - voltha open-onu $VOLTHA_ADAPTER_OPEN_ONU_CHART $VOLTHA_ADAPTER_OPEN_ONU_CHART_VERSION "Install OpenONU Adapter"
        else
            espin - $VERIFIED
        fi
        EXPECT=$(expr $EXPECT + 2)
    fi

    ADAPTERS="adapter-.*"
    wait_for_pods - "voltha" $EXPECT "includes" -1 "Waiting for adapters to start" $ADAPTERS
    if [ "$WITH_TIMINGS" == "yes" ]; then
        printtime $(expr $(date +%s) - $STIME)
    fi
fi

if [ $WITH_BBSIM == "yes" ]; then
    STIME=$(date +%s)
    echo -e "Verify BBSIM $PLUG"
    bspin - "Verify BBSIM Installed"
    for instance in $(seq 0 $(($NUM_OF_BBSIM-1))); do
        if [ $instance -eq 0 ]; then
            instance_num=""
        else
            instance_num=$instance
        fi
        if [ $(helm list --deployed --short --namespace voltha "^bbsim${instance_num}\$" | wc -l) -ne 1 ]; then
            espin - $NOT_VERIFIED
            SAVED=$EXTRA_HELM_INSTALL_ARGS
            EXTRA_HELM_INSTALL_ARGS+=" --set olt_id=$instance"
            helm_install - voltha bbsim${instance_num} $VOLTHA_BBSIM_CHART $VOLTHA_BBSIM_CHART_VERSION "Install BBSIM${instance_num}"
            EXTRA_HELM_INSTALL_ARGS=$SAVED
        else
            espin - $VERIFIED
        fi
    done
    wait_for_pods - "voltha" $NUM_OF_BBSIM "includes" -1 "Waiting for BBSIM to start" "bbsim*"
    if [ "$WITH_TIMINGS" == "yes" ]; then
        printtime $(expr $(date +%s) - $STIME)
    fi
fi

if [ $WITH_RADIUS == "yes" ]; then
    STIME=$(date +%s)
    echo -e "Verify RADIUS $LOCK"
    bspin - "Verify RADIUS Installed"
    if [ $(helm list --deployed --short --namespace voltha "^radius\$" | wc -l) -ne 1 ]; then
        espin - $NOT_VERIFIED
        helm_install - voltha radius onf/freeradius latest "Install RADIUS"
    else
        espin - $VERIFIED
    fi
    wait_for_pods - "voltha" 1 "includes" -1 "Waiting for RADIUS to start" "radius-.*"
    if [ "$WITH_TIMINGS" == "yes" ]; then
        printtime $(expr $(date +%s) - $STIME)
    fi
fi

if [ $WITH_PORT_FORWARDS == "yes" ]; then
    STIME=$(date +%s)
    bspin - "Forward VOLTHA API port $FORWARD"
    kill_port_forward voltha-api
    port_forward voltha voltha-api $VOLTHA_API_PORT 55555
    espin - $VERIFIED
    bspin - "Forward VOLTHA ETCD port $FORWARD"
    kill_port_forward voltha-etcd-cluster-client
    port_forward voltha voltha-etcd-cluster-client $VOLTHA_ETCD_PORT 2379
    espin - $VERIFIED
    bspin - "Forward VOLTHA Kafka port $FORWARD"
    kill_port_forward voltha-kafka
    port_forward voltha voltha-kafka $VOLTHA_KAFKA_PORT 9092
    espin - $VERIFIED
    if [ "$WITH_TIMINGS" == "yes" ]; then
        printtime $(expr $(date +%s) - $STIME)
    fi
fi

if [ $WITH_ONOS == "yes" -a $WITH_RADIUS == "yes" ]; then
    bspin "Configure ONOS RADIUS Connection $GEAR"
    (set -x; cat onos-files/onos-aaa.json | sed -e "s/:RADIUS_IP:/$(kubectl -n voltha get service/radius -o jsonpath={.spec.clusterIP})/g" | curl --fail -sSL --user karaf:karaf -X POST http://$_ONOS_API_EP/onos/v1/network/configuration/apps/org.opencord.aaa -H Content-type:application/json -d@- >>$LOG 2>&1) >>$LOG 2>&1
    espin $VERIFIED
fi

if [ "$WITH_CHAOS" == "yes" ]; then
    STIME=$(date +%s)
    echo -e "Verify kube-monkey $LOCK"
    bspin - "Verify kube-monkey Installed"
    if [ $(helm list --deployed --short --namespace kube-monkey "^monkey\$" | wc -l) -ne 1 ]; then
        espin - $NOT_VERIFIED
        helm_install - kube-monkey monkey ./kube-monkey/helm/kubemonkey latest "Install Chaos Monkey"
    else
        espin - $VERIFIED
    fi
    wait_for_pods - "kube-monkey" 1 "includes" -1 "Waiting for Chaos to start" "monkey-.*"
    if [ "$WITH_TIMINGS" == "yes" ]; then
        printtime $(expr $(date +%s) - $STIME)
    fi
fi

bspin "Create voltctl configuration file"
(set -x; mkdir -p $HOME/.volt >>$LOG 2>&1) >>$LOG 2>&1
MIN_VC_VERSION=$(echo -e "1.0.15\n$VC_VERSION" | sort -V | head -1)
if [ $WITH_PORT_FORWARDS == "yes" ]; then
    KAFKA_FLAG="-k localhost:$VOLTHA_KAFKA_PORT"
    SERVER_FLAG="-s localhost:$VOLTHA_API_PORT"
    ETCD_FLAG=
    if [ "$MIN_VC_VERSION" == "1.0.15" ]; then
        ETCD_FLAG="-e localhost:$VOLTHA_ETCD_PORT"
    fi
else
    KAFKA_FLAG="-k $(get_service_ep voltha voltha-kafka)"
    SERVER_FLAG="-s $(get_service_ep voltha voltha-api)"
    ETCD_FLAG=
    if [ "$MIN_VC_VERSION" == "1.0.15" ]; then
        ETCD_FLAG="-e $(get_service_ep voltha voltha-etcd-client)"
    fi
fi
(set -x; voltctl -a v3 $KAFKA_FLAG $SERVER_FLAG $ETCD_FLAG config > $HOME/.volt/config-$NAME 2>>$LOG) >>$LOG 2>&1
espin $VERIFIED

if [ ! -f "$NAME-env.sh" ]; then
    touch $NAME-env.sh
fi

for O in $ALL_OPTIONS; do
    VAL=$(eval echo \$$O)
    if [ ! -z "$VAL" -a $(grep -c "^export $O=" $NAME-env.sh) -eq 0 ]; then
        echo "export $O=\"$(eval echo \$$O)\"" >> $NAME-env.sh
    fi
done

if [ $DEPLOY_K8S == "yes" -a $(grep -c "^export KUBECONFIG=" $NAME-env.sh) -eq 0 ]; then
    echo "export KUBECONFIG=\"$(./bin/kind get kubeconfig-path --name=voltha-$NAME)\"" >> $NAME-env.sh
fi

if [ $(grep -c "^export VOLTCONFIG=" $NAME-env.sh) -eq 0 ]; then
    echo "export VOLTCONFIG=\"$HOME/.volt/config-$NAME\"" >> $NAME-env.sh
fi

if [ $(grep -c "^export PATH=" $NAME-env.sh) -eq 0 ]; then
    echo "export PATH=\"$GOPATH/bin:\$PATH\"" >> $NAME-env.sh
fi

echo ""
echo "Please issue the following commands in your terminal to ensure that you" | tee -a $LOG
echo "are accessing the correct Kubernetes/Kind cluster as well as have the  " | tee -a $LOG
echo "tools required by VOLTHA in your command path.                         " | tee -a $LOG
echo "" | tee -a $LOG
echo -en $BOLD
if [ $DEPLOY_K8S == "yes" ]; then
    echo "export KUBECONFIG=\"\$(./bin/kind get kubeconfig-path --name=\"voltha-$NAME\")\"" | tee -a $LOG
fi
echo "export VOLTCONFIG=\"$HOME/.volt/config-$NAME\"" | tee -a $LOG
echo "export PATH=$GOPATH/bin:\$PATH" | tee -a $LOG
echo -en $NORMAL
echo "" | tee -a $LOG
echo "Thank you for choosing kind-voltha for you quick cluster needs." | tee -a $LOG

if [ "$WITH_TIMINGS" == "yes" ]; then
    echo -e "$CLOCK  ${BOLD}TOTAL: $(duration $(expr $(date +%s) - $TOTAL_START_TIME))${NORMAL}"
fi